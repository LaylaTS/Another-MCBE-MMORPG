//Slash Shape by ReBrainerTV version 1.0.2
export default defineCommand(({ name, template, schema }) => {
	name('shape')
	schema([
		{
			description: "Returns each coordiante in the a shape you specify. Like /fill, but you can use its coordinates in the following command. The command will be run once at each coordinate in the shape (reference position using \"~ ~ ~\").",
			arguments: [
				{ type: "string", additionalData: { values: ["rectangle"] } }, //Type of shape to do
				{ type: "string", additionalData: { values: ["filled", "outline"] } }, //Filled in?
				{ type: "coordinate" }, //Start corner X
				{ type: "coordinate" }, //Start corner Y
				{ type: "coordinate" }, //Start corner Z
				{ type: "coordinate" }, //End corner X
				{ type: "coordinate" }, //End corner Y
				{ type: "coordinate" }, //End corner Z
				{ type: "command" } //Command.
				//Wherever you want the shape's coordiantes to be inserted in your command, use & coordinate notation instead of ~ or ^.
			]
		}/*,
		{
			description: "Returns each coordiante in the a shape you specify. Like /fill, but you can use its coordinates in the following command. Reference the coordiantes generated by using \"& & &\" in place of coordinates. ",
			arguments: [
				{ type: "string", additionalData: { values: ["line"] } },
				{ type: "coordinate" }, //Start corner X
				{ type: "coordinate" }, //Start corner Y
				{ type: "coordinate" }, //Start corner Z
				{ type: "coordinate" }, //End corner X
				{ type: "coordinate" }, //End corner Y
				{ type: "coordinate" }, //End corner Z
				{ type: "command" }
			]
		}*/
	])

	template((args, { compileCommands, commandNestingDepth, compilerMode }) => {
		var coordslist = [];
		//args[0] should be 'rectangle'.

		//Values split into coodinate modifier and raw number
		var fromog = [[], [], []];
		var toog = [[], [], []];

		for (var i = 2; i < 5; i++) {
			if (args[i].constructor == Number) {
				fromog[i][0] = "";
				fromog[i][1] = args[i];
			} else if (args[i].includes("~")) {
				fromog[i][0] = "~";
				fromog[i][1] = parseFloat(args[i].replaceAll("~", "").replaceAll("^", ""));
			} else if (args[i].includes("^")) {
				fromog[i][0] = "^";
				fromog[i][1] = parseFloat(args[i].replaceAll("~", "").replaceAll("^", ""));
			}
		}

		for (var i = 5; i < 8; i++) {
			if (args[i].constructor == Number) {
				toog[i][0] = "";
				toog[i][1] = args[i];
			} else if (args[i].includes("~")) {
				toog[i][0] = "~";
				toog[i][1] = parseFloat(args[i].replaceAll("~", "").replaceAll("^", ""));
			} else if (args[i].includes("^")) {
				toog[i][0] = "^";
				toog[i][1] = parseFloat(args[i].replaceAll("~", "").replaceAll("^", ""));
			}
		}

		//Get raw coordinate numbers
		var x1 = fromog[0][1]; var x2 = toog[0][1];
		var y1 = fromog[1][1]; var y2 = toog[1][1];
		var z1 = fromog[2][1]; var z2 = toog[2][1];

		//Calculate start and end positions
		var startx = (x1 >= x2 ? x2 : x1);
		var starty = (y1 >= y2 ? y2 : y1);
		var startz = (z1 >= z2 ? z2 : z1);
		var endx = (x1 >= x2 ? x1 : x2) + 1;
		var endy = (y1 >= y2 ? y1 : y2) + 1;
		var endz = (z1 >= z2 ? z1 : z2) + 1;

		//Prepare calculated values for looping
		var x, y, z, width, height, depth, ix, iy, iz;
		x = startx; y = starty; z = startz;
		width = endx - x; height = endy - y; depth = endz - z;

		if (args[1] == "filled") {
			//Shape filled
			for (iy = 0; iy < height; iy++) {
				for (var ix = 0; ix < width; ix++) {
					for (var iz = 0; iz < depth; iz++) {
						coordslist.push([
							fromog[0][0] + (ix + x),
							fromog[1][0] + (iy + y),
							fromog[2][0] + (iz + z)
							//Prefix + number generated
						]);
					}
				}
			}
		} else if (args[1] == "outline") {
			//Shape hollow
			for (iy = 0; iy < height; iy++) {
				if (iy == (height - 1) || iy == 0) {
					//Bottom or top layer, do entire thing.
					for (var ix = 0; ix < width; ix++) {
						for (var iz = 0; iz < depth; iz++) {
							coordslist.push([
								fromog[0][0] + (ix + x),
								fromog[1][0] + (iy + y),
								fromog[2][0] + (iz + z)
								//Prefix + number generated
							]);
						}
					}
				} else {
					//Not bottom or top layer, go around the edges
					for (var ix = 0; ix < width; ix++) {
						if (ix == (width - 1) || ix == 0) {
							//On top or bottom edge
							for (var iz = 0; iz < depth; iz++) {
								coordslist.push([
									fromog[0][0] + (ix + x),
									fromog[1][0] + (iy + y),
									fromog[2][0] + (iz + z)
									//Prefix + number generated
								]);
							}
						} else {
							//Not on top or bottom edge
							for (var iz = 0; iz < depth; iz++) {
								if (iz == (depth - 1) || iz == 0) {
									//On left or right edge
									coordslist.push([
										fromog[0][0] + (ix + x),
										fromog[1][0] + (iy + y),
										fromog[2][0] + (iz + z)
										//Prefix + number generated
									]);
								} else {
									//Not on left or right edge
									//Do nothing
								}
							}
						}
					}
				}
			}
		} else {
			//Invalid argument type, do nothing
		}
		//Parse args[2, 3, 4] to make them readable as numbers while still keeping their respective coordinate modifiers.
		//args[5,6,7] are already numbers and need no operations.
		//args[8..] are part of the command.


		var command = [];
		for (var i = 0; i < args.length - 8; i++) {
			//Any argument after 8, consider it part of the command to use.
			command.push(args[i + 8]);
		}
		command = command.join(" ");
		/* v1.0.1 (does not support custom commands, use &&& to reference position)
		var cmdslist = [];
		for (var i = 0; i < coordslist.length; i++) {
			var cmd = command.join("-=#&#=-").split("-=#&#=-");
			for (var a = 0; a < cmd.length; a++) {
				if (cmd[a] == "&") {
					//The user wants a coordiante inputted here, now we have to find whether it's X, Y or Z
					if (cmd[a + 1] == "&") {
						if (cmd[a + 2] == "&") {
							//X
							cmd[a] = coordslist[i][0];
						} else {
							//Y
							cmd[a] = coordslist[i][1];
						}
					} else {
						//Z
						cmd[a] = coordslist[i][2];
					}
				}
			}
			cmdslist.push(cmd.join(" "));
		}
		*/

		//  v1.0.2 (supports custom commands, use ~~~ to reference position)
		var cmdslist = [];

		var compiledCommands = compileCommands([command]);
		for (var i = 0; i < coordslist.length; i++) {
			var myCompiledCommands = JSON.parse(JSON.stringify(compiledCommands));
			for (var a = 0; a < myCompiledCommands.length; a++) {
				myCompiledCommands[a] = "execute @s " + coordslist[i].join(" ") + " " + myCompiledCommands[a];
			}
			cmdslist = cmdslist.concat(myCompiledCommands);
		}

		return cmdslist;
	})
})